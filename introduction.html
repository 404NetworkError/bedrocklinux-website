<!doctype html>
<!-- boilerplate -->
<html lang=en>
	<meta charset=utf-8>
	<title>Bedrock Linux: Introduction</title>
	<link rel=stylesheet href=bedrock.css>
	<body>

		<!-- header -->

		<div id=header>
			<!-- logo -->
			<a id=logo href="index.html">
				<div id=logoshrinkwrap>
<pre>__          __             __      
\ \_________\ \____________\ \___  
 \  _ \  _\ _  \  _\ __ \ __\   /  
  \___/\__/\__/ \_\ \___/\__/\_\_\ </pre>
				</div>
			</a>

			<!-- navbock -->
			<!-- content is 3 lines high, top line is three wide -->
			<ul id=navvert>
				<li>
					<ul id=navhoriz>
						<li>
							<a href="introduction.html">Introduction</a>
						</li>
						<li>
							<a href="faq.html">FAQ</a>
						<li>
						<li>
							<a href="todo.html">TODO</a>
						<li>
					</ul>
				</li>
				<li>
					<a href="http://webchat.freenode.net/?channels=bedrock">IRC: #bedrock on freenode</a>
				</li>
				<li>
					<a href="1.0alpha2">Current Release (1.0alpha2)</a>
				</li>
			</ul>
		</div>

		<!-- main content -->

		<div id=main>

			<!-- table of contents -->

			<h1>Introduction to Bedrock Linux</h1>
			<ol>
				<li><a href="#The Perfect Linux Distribution">The Perfect Linux Distribution</a></li>
				<ol>
					<li><a href="#Bedrock-Only Features">Bedrock-Only Features</a></li>
				</ol>
				<li><a href="#Real-World Examples of where Bedrock Linux Shines">Real-World Examples of where Bedrock Linux Shines</a></li>
				<li><a href="#How Bedrock Linux Works">How Bedrock Linux Works</a></li>
				<ol>
					<li><a href="#Chroot">Chroot</a></li>
					<li><a href="#Bind Mounts">Bind Mounts</a></li>
					<li><a href="#PATH">PATH</a></li>
				</ol>
				<li><a href="#Design Choices">Design Choices</a></li>
				<ol>
					<li><a href="#Simplicity">Simplicity</a></li>
					<li><a href="#Minimalism and Deferring Features">Minimalism and Deferring Features</a></li>
					<li><a href="#Statically-linked Executables">Statically-linked Executables</a></li>
					<li><a href="#Manual Client Init Scripts">Manual Client Init Scripts</a></li>
					<li><a href="#Self-sufficient Booting">Self-sufficient Booting</a></li>
				</ol>
				<li><a href="#Package choices">Package choices</a></li>
				<ol>
					<li><a href="#Bootloader: Syslinux">Bootloader: Syslinux</a></li>
					<li><a href="#Userland: Busybox">Userland: Busybox</a></li>
					<li><a href="#Chroot: Capchroot">Chroot: Capchroot</a></li>
					<li><a href="#Shell scripts">Shell scripts</a></li>
				</ol>
				<li><a href="#Bedrock Linux Scripts">Bedrock Linux Scripts</a></li>
				<ol>
					<li><a href="#brc">brc</a></li>
					<li><a href="#brs">brs</a></li>
					<li><a href="#brp">brp</a></li>
					<li><a href="#brl">brl</a></li>
					<li><a href="#bru">bru</a></li>
					<li><a href="#brsh">brsh</a></li>
				</ol>
			</ol>

			<!-- actual main content -->

			<h2 id="The Perfect Linux Distribution">The Perfect Linux Distribution</h2>
			<p>
				So you've decided to give this Linux thing a try.  Which Linux
				distribution should you choose?  Do you want...
			</p>
			<ul>
				<li>
					Something extremely stable, such as Debian or a Red Hat
					Enterprise Linux clone?
				</li>
				<li>
					Something cutting-edge, such as Arch, Debian Sid, or Fedora
					Rawhide?
				</li>
				<li>
					Something extremely customizable, such as Gentoo or
					LinuxFromScratch?
				</li>
				<li>
					Something minimal, such as Tinycore or SliTaz?
				</li>
				<li>
					Something user-friendly, such as Mint?
				</li>
				<li>
					Something popular with lots of software developed with it
					in mind, such as Ubuntu?
				</li>
			</ul>
			<p>
				Which features are important, and which are you willing to give up?  If
				you want <small>(almost<sup>1</sup>)</small> <em>everything</em> -
				stable and cutting edge, customizable and minimal, with access to
				popular-distro-only packages - Bedrock Linux is the Linux distribution
				for you.
			</p>
			<p>
				<small><sup>1</sup>Well, everything except for user-friendly.
					At the moment, Bedrock Linux can not honestly be considered
					"user-friendly."</small>
			</p>
			<h3 id="Bedrock-Only Features">Bedrock-Only Features</h3>
			<p>
				In addition to doing <small>(almost)</small> anything any other
				Linux distribution can do, there are a number of things Bedrock
				Linux can do which no other distribution can.
			</p>
			<ul>
				<li>
					You can do a distro-upgrade (Debian 5 to 6, Ubuntu 12.04 to
					12.10, etc), <em>live, with almost no downtime</em>.  No
					need to stop your apache server, reboot, configure things
					while the server is down, etc.
				</li>
				<li>
					If a distro-upgrade breaks anything, no problem - the old
					release's program and settings can still be there, ready to
					go to pick up what it was doing before the distro-upgrade
					broke anything.
				</li>
				<li>
					Minimal stress from any given package failing to work -
					just use one from another Linux distribution.  Packages
					feel disposable, like toothpicks.  No need to fret over one
					breaking; just use another.
				</li>
			</ul>
			<h3 id="Real-World Examples of where Bedrock Linux Shines">Real-World Examples of where Bedrock Linux Shines</h3>
			<p>
				These are all examples of real-world situations which came up
				while Bedrock Linux was in development which showed quite
				clearly Bedrock's strength.
			</p>
			<ul>
				<li>
					When Quake Live's Linux release came out, there was a bug
					which only seemed to manifest itself against Debian's X11.
					The development team most likely tested against Ubuntu, and
					so the situation was resolved by using Ubuntu's X11 (and
					only that from Ubuntu, with the majority of the rest of the
					system remained Debian).  Just as Debian was overly old for
					Quake Live at its release, Arch Linux users later faced the
					flip side of that coin: their cutting-edge libraries were
					causing issues with Quake Live.  One way this was resolved
					was to play with <code>LD_PRELOAD</code>.  Bedrock Linux
					users, however, could continue using Arch Linux's
					cutting-edge packages and use Quake Live without having to
					touch <code>LD_PRELOAD</code>.
				</li>
				<li>
					With only a few days to go before presenting Compiz at a
					local Free/Open Source Software enthusiast club, the
					presenter found Debian's video drivers for his laptop were
					overly old to support the 3D acceleration needed for
					Compiz.  While Arch Linux's X11 video drivers were new
					enough, its Compiz package did not work at the time.
					Bedrock Linux allowed for a quick and easy solution: use
					Arch Linux's X11 with Debian's Compiz.
				</li>
				<li>
					Arch Linux was one of the few Linux distributions with the
					mathematics program Sage available in its repository.
					However, for a period of time Sage was dropped from the
					repository due to compatibility issues with Arch Linux.
					Sage is only pre-packaged for and tested against a handful
					of Linux distributions, one of which is Ubuntu.  Thus all
					Bedrock Linux users had to do was to download it for
					Ubuntu.  Arch Linux users had to struggle with the
					compatibility issues, and Ubuntu users never benefited from
					the period of time when Sage was available from a
					repository.
				</li>
			</ul>
			<h2 id="How Bedrock Linux Works">How Bedrock Linux Works</h2>
			<p>
				Bedrock's magic is based around filesystem and PATH
				manipulation.
			</p>
			<h3 id="Chroot">Chroot</h3>
			<p>
				A <em>chroot</em> changes the apparent filesystem layout from
				the point of view of programs running within it.  Specifically,
				it makes a chosen directory appear to be the root of the
				filesystem.  Think of it prepending a given string to the
				beginning of every filesystem call.  For example:
			</p>
			<ul>
				<li>
					Firefox is located in
					<code>/var/chroot/arch/user/bin/firefox</code>.
				</li>
				<li>
					The following code is run: <code>chroot /var/chroot/arch
						/usr/bin/firefox</code>.
				</li>
				<li>
					To any executables launched as children of this one, all of
					their filesystem calls will have
					<code>/var/chroot/arch</code> added to their beginnings.
					That directory will be treated as though it is the root
					directory.
				</li>
				<li>
					As an initial child program, what would be located at
					<code>/usr/bin/firefox</code> if
					<code>/var/chroot/arch</code> is root is run.
					<code>/usr/bin/firefox</code> with
					<code>/var/chroot/arch</code> prepended to the front of it
					yields <code>/var/chroot/arch/usr/bin/firefox</code>, and
					thus the firefox executable located there is run.
				</li>
				<li>
					The newly launched firefox
					<em>thinks</em> it is located at
					<code>/usr/bin/firefox</code>
				</li>
				<li>
					When Firefox tries to load a file at
					<code>/usr/lib/libgtk2.0-0</code>,
					<code>/var/chroot/arch</code> is prepended to the call, and
					thus it actually gets the file located at
					<code>/var/chroot/arch/usr/lib/libgtk2.0-0</code>
				</li>
			</ul>
			<p>
				Bedrock Linux retains within its own filesystem the full
				filesystems of other Linux , each in their own directory.
				These other Linux distributions are refered to as
				<em>clients</em>.  If one would like to run a program from any
				given client, via chroot, the program can be tricked into
				thinking that is running in its native Linux distribution.  It
				would read the proper libraries and support programs and, for
				the most part, just work.
			</p>
			<h3 id="Bind Mounts">Bind Mounts</h3>
			<p>
				Linux can take mountable devices (such as usb sticks) and make
				their filesystems accessible at any folder on the (virtual)
				filesystem.  Mounting usb sticks to places such as
				<code>/media/usbstick</code> or <code>/mnt/usbstick</code> is
				typical, but not required - just about any directory will work.
				Linux can also mount virtual filesystems, such as
				<code>/proc</code> and <code>/sys</code>. These do not actually
				exist on the harddrive - they are simply a nice abstraction
			</p>
			<p>
				Moreover, Linux can <em>bind mount</em> just about any
				directory (or file, actually) to any other directory (or file).
				Think of it as a shortcut.  This can "go through" chroots to
				make files outside of a chroot accessible inside (unlike
				symlinks).
			</p>
			<p>
				With bind mounts you can, for example, ensure you only have to
				maintain a single <code>/home</code> on Bedrock. That
				<code>/home</code> can be bind mounted into each of the
				chrooted client filesystems so that they all share it. If you
				arbitrarily decide to stop using one client's firefox and start
				using another's, you can keep using your same
				<code>~/.mozilla</code> - things will "just work."
			</p>
			<p>
				Through proper usage of chroots and bind mounts, Bedrock Linux
				can tweak the filesystem from the point of view of any program
				to ensure they have access to the files they need to run
				properly while ensuring the system feels integrated and
				unified.
			</p>
			<h3 id="PATH">PATH</h3>
			<p>
				Programs read your <code>$PATH</code> environmental variable to
				see where to look for executables, and your
				<code>$LD_LIBRARY_PATH</code> for libraries.  For example, with
				<code>PATH="/usr/local/bin:/usr/bin:/bin"</code>, when you
				attempt to run <code>firefox</code>, the system will check for
				an executable named <code>firefox</code> in the following
				locations (in the following order):
			</p>
			<ul>
				<li>
					<code>/usr/local/bin/firefox</code>
				</li>
				<li>
					<code>/usr/bin/firefox</code>
				</li>
				<li>
					<code>/bin/firefox</code>
				</li>
			</ul>
			<p>
				Using a specialized <code>$PATH</code> variable, Bedrock Linux
				can have a program attempt to run a (chrooted) program in
				another client Linux distribution rather than only looking for
				its own versions of things.  By changing the order of the
				elements in the <code>$PATH</code> variable, search order can
				be specified.
			</p>
			<h2 id="Design Choices">Design Choices</h2>
			<p>
				Due to Bedrock's unusual goals, several unusual design choices
				were made. These choices were the reason Bedrock Linux needs to
				be its own distribution rather than simply a system grafted
				onto another Linux distribution.
			</p>
			<h3 id="Simplicity">Simplicity</h3>
			<p>
				Understanding Bedrock's filesystem layout (with the chroots,
				bind mounts, and dynamic <code>$PATH</code>) can be quite
				confusing.  Additionally, no user-friendly standalone installer
				with pre-compiled packages will be available for quite some
				time; users will be required to compile Bedrock Linux "from
				scratch." Moreover, users will have to maintain things on a
				very low level; they will be expected to, for example,
				hand-edit the init files (reasoning explained later).  In order
				to ensure Bedrock Linux is viable for as many users as
				possible, everything which does not have to be confusing or
				complicated should be made as simple as possible.
			</p>
			<p>
				Bedrock Linux thus chooses some unusual packages. GRUB, the
				de-facto bootloader for most major Linux distributions, is a
				tad complicated. Syslinux is significantly easier to setup and
				maintain by hand, and thus is the "official" choice for
				Bedrock.  However, GRUB should work fine, if the user wants to
				figure out how to install and manage it himself.
			</p>
			<h3 id="Minimalism and Deferring Features">Minimalism and Deferring Features</h3>
			<p>
				Most major Linux distributions have much larger and more
				experienced teams. Where directly comparable, they are most
				likely better than the Bedrock Linux developer at
				Linux-distribution-making.  Thus, where possible, it is
				preferable to use functionality from a client rather than
				Bedrock Linux itself. If something can be deferred to a client
				it will be; Bedrock Linux only does what it has to do to enable
				the integration of other Linux distributions.
			</p>
			<h3 id="Statically-linked Executables">Statically-linked Executables</h3>
			<p>
				Typically, most executables refer to other libraries for their
				components. If this is done at runtime, this is known as
				<em>dynamic linking</em>. By contrast, one can (sometimes)
				<em>statically link</em> the libraries into the executable when
				compiling.
			</p>
			<p>
				When using dynamically linked executables, the libraries for the
				executable must be available at run time. This is why you can not
				simply take an executable from one Linux distribution and run it on
				another - if the libraries do not match what it was compiled
				against, it will not work. Statically linked executables can,
				however, run just about anywhere irrelevant of libraries (of
				course, one still needs the same kernel, CPU instruction set, etc).
			</p>
			<p>
				In order to ensure the following items, Bedrock's core components
				are all statically linked:
			</p>
			<ul>
				<li>
					It should be possible to run a core Bedrock Linux
					executable directly in any of the clients without worrying
					about chroots.  This is especially important for the chroot
					program itself.
				</li>
				<li>
					It should be possible to compile a core Bedrock Linux
					component in any client Linux distribution which supports
					compiling statically-linked executables and simply dump it
					into place to update the component.
				</li>
			</ul>
			<p>
				Note that clients may freely use dynamically linked
				executables; this is only important for core Bedrock Linux
				components.
			</p>
			<p>
				It should be noted that statically linked compiling is frowned upon
				by many people who are knowledgeable on the subject.  For
				example, <a
					href="https://docs.redhat.com/docs/en-US/Red_Hat_Enterprise_Linux/6/html/Developer_Guide/lib.compatibility.static.html">Red
					Hat is staunchly against it:</a>
			</p>
				<blockquote>
					Static linking is emphatically discouraged for all Red Hat
					Enterprise Linux releases. Static linking causes far more problems
					than it solves, and should be avoided at all costs.
				</blockquote>
			<p>
				<a href="http://www.akkadia.org/drepper/no_static_linking.html">Another link:</a>
			</p>
				<blockquote>
					Conclusion: Never use static linking!
				</blockquote>
			<p>
				The Bedrock Linux developer believes that Bedrock's unique
				situation creates a justifiable exemption, but do your own
				research.
			</p>
			<p>
				It should be noted that another Linux-distribution-in-progress, <a
					href="http://dl.suckless.org/stali/clt2010/stali.html">stali
					from suckless</a>, also makes heavy use of static compilition.
			</p>
			<h3 id="Manual Client Init Scripts">Manual Client Init Scripts</h3>
			<p>
				Most Linux distributions automatically manage the programs
				which are run at startup and shutdown, but Bedrock Linux will
				not be one of them for the foreseeable future. It is quite
				possible (and, in fact, likely) that multiple clients will have
				startup and shutdown scripts which conflict with those from
				other clients.  Moreover, there are a variety of Linux init
				systems, each of which have their own system for ensuring the
				programs are launched in the proper order to meet their
				prerequisites.
			</p>
			<p>
				The Bedrock Linux developer has been unable to think of any
				sane way of determining which init script to run when the
				clients conflict (which CUPS daemon should run, if multiple are
				available?).  Additionally, an automated way to determine the
				launch order from all of the possible systems it will run into
				seems far to challenging of a project.  Thus, Bedrock Linux
				requires manually setting which programs from which client's
				init is launched when.
			</p>
			<h3 id="Self-sufficient Booting">Self-sufficient Booting</h3>
			<p>
				The Bedrock Linux developer feels strongly that
				<ul>
					<li>
						Bedrock Linux should be able to boot and do (very)
						basic tasks without any clients.
					</li>
					<li>
						Bedrock Linux should be able to boot even if a client
						unexpectedly break.
					</li>
				</ul>
				This means that if one would like a client to do something
				required when booting (for example, manage <code>/dev</code>),
				core Bedrock Linux will have to do this first itself.  Only
				later, after the essentials are done and the system is
				functional, will the core Bedrock Linux stop its management of
				<code>/dev</code> and let a client take over.
			</p>
			<h2 id="Package choices">Package choices</h2>
			<h3>Kernel: Linux</h3>
			<p>
				No other operating system kernel has such a great variety of
				userland options which could benefit from Bedrock's unique
				userland sharing system.
			</p>
			<h3 id="Bootloader: Syslinux">Bootloader: Syslinux</h3>
			<p>
				This is the simplest bootloader the Bedrock Linux developer
				knows of.  Setting it up is just a handful of commands.
			</p>
			<h3 id="Userland: Busybox">Userland: Busybox</h3>
			<p>
				Busybox is an all-in-one solution for a minimal(/embedded)
				Linux userland. It is significantly smaller and easier to set
				up than most of its alternatives. Statically-linking it is
				relatively common, and it can be found in many Linux
				distribution client repositories statically-compiled.
			</p>
			<h3 id="Chroot: Capchroot">Chroot: Capchroot</h3>
			<p>
				The standard chroot command requires root. If setuid'd it is
				quite possible to use chroot to escalate privileges. Thus,
				Bedrock Linux requires a specialized chroot package intended to
				be used by non-root users. The typical choice for such things,
				schroot, was found to be overly large, complicated, and
				difficult to compile statically. Instead, Bedrock Linux uses a
				little-known program called capchroot. This still requires some
				patches to be compiled statically linked against glibc, but is
				otherwise ideal.
			</p>
			<h3 id="Shell scripts">Shell scripts</h3>
			<p>
				Additionally, Bedrock Linux uses some of its own shell scripts
				(using busybox's <code>/bin/sh</code>) for things such as
				booting and integrating the system. Since busybox was already
				chosen, using its shell scripting option was an obvious choice.
			</p>
			<h2 id="Bedrock Linux scripts">Bedrock Linux scripts</h2>
			<h3 id="brc">brc</h3>
			<p>
			<code>brc</code> is a front-end for capchroot and is the main way
			users will manually run commands from clients.  For example,
			<code>brc fedora firefox</code> will run Fedora's firefox, even if
			the <code>firefox</code> command would normally default to another
			client's firefox.  <code>brc</code> will detect when preparation
			for setting up a client is needed and automatically default to
			running a shell if no arguments are given.
			</p>
			<h3 id="brs">brs</h3>
			<p>
			<code>brs</code> will set up clients.  This can be set to run
			automatically to avoid any delay that would occure when trying to
			run brc to access a not-yet-setup client.
			</p>
			<h3 id="brp">brp</h3>
			<p>
				Early versions of Bedrock Linux would try to detect if you tried to run a
				command which isn't available and, on the fly, attempt to find the
				command in a client. This proved to slow. Instead, Bedrock's
				<code>brp</code> command will hash the available commands from
				within the client is run in.
			</p>
			<h3 id="brl">brl</h3>
			<p>
				The <code>brl</code> command will run its argument in all available
				clients. If, for example, you want to test to ensure that all of
				your clients have internet access, you ccould run the following:
				<code>brl ping -c 1 google.com</code>
			</p>
			<h3 id="bru">bru</h3>
			<p>
				Updating all of the clients is a very common task, and so
				<code>bru</code> was created to make it a simple one.
				<code>bru</code> can be used to update all of the clients in a
				single command.
			</p>
			<h3 id="brsh">brsh</h3>
			<p>
				Due to its purposeful minimalism, the core Bedrock Linux
				install only includes busybox's very limited shells; users will
				most likely want to use a client's shells by default. However,
				this raises three problems:
			</p>
			<ul>
				<li>
					What if the user needs to log into the core Bedrock's busybox's
					<code>/bin/sh</code>? For example, maybe the chroot system
					broke, or he/she is debugging a busybox update.
				</li>
				<li>
					What if the chroot system is fine but the client breaks?  What
					if the user forgets that he/she uses the client's shell and
					removes the client?
				</li>
				<li>
					<code>/etc/passwd</code> requires the full path to shells.
					The full path to the shell could easily change depending on
					which client is running it.  The core Bedrock Linux may
					attempt to run a shell from Debian at
					<code>/var/local/brpath/zsh</code>, and when Debian will
					attempt to its own local version of the shell at
					<code>/bin/zsh</code>.
				</li>
			</ul>
			<p>
				Bedrock Linux provides two options to resolve these issues:
			</p>
			<ol>
				<li>
					Bedrock Linux has its own meta-shell, <code>brsh</code>,
					which will log in to a configured client's shell, if
					available.  If it is not available, it will automatically
					drop to <code>/bin/sh</code> if it is available in the
					client, and if not, then it drops down to the core
					Bedrock's <code>/bin/sh</code>.  The path to
					<code>brsh</code> should remain in the same location
					(<code>/opt/bedrock/bin/brsh</code>) irrelevant of which
					client is running it, meaning it will work in
					<code>/etc/passwd</code> while still allowing access to
					shells which have changing paths.
				</li>
				<li>
					The traditional Unix <code>/etc/passwd</code> allows
					creating multiple entries with different login names and
					different shells but same password, home, etc, for the same
					user.  For example:<br>
					<code>root:x:0:0:root:/root:/opt/bedrock/bin/brsh</code><br>
					<code>brroot:x:0:0:root:/root:/bin/sh</code><br>
					This can be advantageous over <code>brsh</code> as (1) it
					should work if <code>brsh</code> fails to detect a client
					has broken, and (2) it does not require logging in,
					changing the <code>brsh</code> configuration file, then
					logging back out, and logging back in again.
				</li>
			</ol>
		</div>

		<!-- footer -->

		<div id=footer>
			<ul>
				<li>
					<a href="index.html">Home</a>
				</li>
				<li>
					<a href="introduction.html">Introduction</a>
				</li>
				<li>
					<a href="faq.html">FAQ</a>
				</li>
				<li>
					<a href="todo.html">TODO</a>
				</li>
				<li>
					<a href="http://webchat.freenode.net/?channels=bedrock">IRC: #bedrock on freenode</a>
				</li>
			</ul>
		</div>
	</body>
</html>
